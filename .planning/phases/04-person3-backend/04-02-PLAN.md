---
phase: 04-person3-backend
plan: 02
type: execute
---

<objective>
Wire the NotificationService with mock Twilio mode for development.

Purpose: Enable notification sending with console logging for mock mode
Output: Working notification service that logs to console (mock) or sends via Twilio (real)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@backend/app/services/notification_service.py - Current notification service with TODOs
@backend/app/api/matches.py - Endpoints that need to call notifications
@backend/.env - Environment configuration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock-aware Twilio client wrapper</name>
  <files>backend/app/services/twilio_client.py</files>
  <action>
    Create a new file `backend/app/services/twilio_client.py` that wraps Twilio with mock support:

    ```python
    import os
    import logging
    from typing import Optional

    logger = logging.getLogger(__name__)

    # Check if we're in mock mode
    USE_MOCK_NOTIFICATIONS = os.getenv("USE_MOCK_NOTIFICATIONS", "true").lower() == "true"


    class TwilioClient:
        """
        Twilio client wrapper with mock mode support.

        When USE_MOCK_NOTIFICATIONS=true (default), logs notifications to console.
        When USE_MOCK_NOTIFICATIONS=false, sends real SMS/WhatsApp via Twilio.
        """

        def __init__(self):
            self.mock_mode = USE_MOCK_NOTIFICATIONS

            if not self.mock_mode:
                try:
                    from twilio.rest import Client
                    account_sid = os.getenv("TWILIO_ACCOUNT_SID")
                    auth_token = os.getenv("TWILIO_AUTH_TOKEN")
                    self.from_phone = os.getenv("TWILIO_FROM_PHONE")
                    self.whatsapp_from = os.getenv("TWILIO_WHATSAPP_FROM")

                    if not all([account_sid, auth_token, self.from_phone]):
                        logger.warning("Twilio credentials incomplete, falling back to mock mode")
                        self.mock_mode = True
                    else:
                        self.client = Client(account_sid, auth_token)
                        logger.info("Twilio client initialized in LIVE mode")
                except ImportError:
                    logger.warning("Twilio package not installed, using mock mode")
                    self.mock_mode = True

            if self.mock_mode:
                logger.info("Twilio client initialized in MOCK mode")

        def send_sms(self, to_phone: str, message: str) -> Optional[str]:
            """
            Send SMS message.

            Returns message SID on success, None on failure.
            In mock mode, logs to console and returns fake SID.
            """
            if self.mock_mode:
                logger.info(f"[MOCK SMS] To: {to_phone}")
                logger.info(f"[MOCK SMS] Message: {message}")
                return "MOCK_SMS_SID_" + to_phone[-4:]

            try:
                msg = self.client.messages.create(
                    body=message,
                    from_=self.from_phone,
                    to=to_phone
                )
                logger.info(f"SMS sent to {to_phone}, SID: {msg.sid}")
                return msg.sid
            except Exception as e:
                logger.error(f"Failed to send SMS to {to_phone}: {e}")
                return None

        def send_whatsapp(self, to_phone: str, message: str) -> Optional[str]:
            """
            Send WhatsApp message.

            Returns message SID on success, None on failure.
            In mock mode, logs to console and returns fake SID.
            """
            if self.mock_mode:
                logger.info(f"[MOCK WhatsApp] To: {to_phone}")
                logger.info(f"[MOCK WhatsApp] Message: {message}")
                return "MOCK_WA_SID_" + to_phone[-4:]

            try:
                # WhatsApp requires whatsapp: prefix
                to_whatsapp = f"whatsapp:{to_phone}" if not to_phone.startswith("whatsapp:") else to_phone
                from_whatsapp = self.whatsapp_from or f"whatsapp:{self.from_phone}"

                msg = self.client.messages.create(
                    body=message,
                    from_=from_whatsapp,
                    to=to_whatsapp
                )
                logger.info(f"WhatsApp sent to {to_phone}, SID: {msg.sid}")
                return msg.sid
            except Exception as e:
                logger.error(f"Failed to send WhatsApp to {to_phone}: {e}")
                return None


    # Singleton instance
    _twilio_client: Optional[TwilioClient] = None


    def get_twilio_client() -> TwilioClient:
        """Get singleton Twilio client instance."""
        global _twilio_client
        if _twilio_client is None:
            _twilio_client = TwilioClient()
        return _twilio_client
    ```
  </action>
  <verify>
    - File created at backend/app/services/twilio_client.py
    - Python syntax is valid: `python -c "from app.services.twilio_client import get_twilio_client"`
    - Mock mode enabled by default
  </verify>
  <done>TwilioClient wrapper created with mock mode support</done>
</task>

<task type="auto">
  <name>Task 2: Wire TwilioClient into NotificationService</name>
  <files>backend/app/services/notification_service.py</files>
  <action>
    Update notification_service.py to use the new TwilioClient:

    Replace the TODO comments with actual calls:

    ```python
    from sqlalchemy.orm import Session
    from typing import Optional
    from uuid import UUID
    import logging

    from app.db.models import User, Activity
    from app.services.twilio_client import get_twilio_client

    logger = logging.getLogger(__name__)


    class NotificationService:
        """
        Service for orchestrating notifications via Twilio

        Handles SMS and WhatsApp notifications for:
        - Registration confirmations
        - Volunteer match confirmations
        - Activity reminders
        - Caregiver notifications
        """

        def __init__(self, db: Session):
            self.db = db
            self.twilio = get_twilio_client()

        async def send_registration_confirmation(
            self,
            user_id: UUID,
            activity_id: UUID
        ) -> None:
            """
            Send registration confirmation to participant

            Also notifies caregiver via WhatsApp if phone number provided
            """
            user = self.db.query(User).filter(User.id == user_id).first()
            activity = self.db.query(Activity).filter(Activity.id == activity_id).first()

            if not user or not activity:
                logger.warning(f"Cannot send confirmation: user={user_id}, activity={activity_id}")
                return

            # Format message
            message = (
                f"Registration Confirmed!\n\n"
                f"Activity: {activity.title}\n"
                f"Date: {activity.date}\n"
                f"Time: {activity.start_time} - {activity.end_time}\n"
                f"Location: {activity.location}"
            )

            # Send SMS to participant
            if user.phone:
                self.twilio.send_sms(user.phone, message)

            # Send WhatsApp to caregiver
            if user.caregiver_phone:
                caregiver_message = f"MINDS Update: {user.full_name or 'Participant'} registered for activity.\n\n{message}"
                self.twilio.send_whatsapp(user.caregiver_phone, caregiver_message)

        async def send_volunteer_match_confirmation(
            self,
            volunteer_id: UUID,
            activity_id: UUID
        ) -> None:
            """Send match confirmation to volunteer"""
            volunteer = self.db.query(User).filter(User.id == volunteer_id).first()
            activity = self.db.query(Activity).filter(Activity.id == activity_id).first()

            if not volunteer or not activity:
                logger.warning(f"Cannot send match confirmation: volunteer={volunteer_id}, activity={activity_id}")
                return

            message = (
                f"You're Matched!\n\n"
                f"Activity: {activity.title}\n"
                f"Date: {activity.date}\n"
                f"Time: {activity.start_time} - {activity.end_time}\n"
                f"Location: {activity.location}\n\n"
                f"Thank you for volunteering!"
            )

            if volunteer.phone:
                self.twilio.send_sms(volunteer.phone, message)

        async def send_activity_reminder(
            self,
            user_id: UUID,
            activity_id: UUID,
            hours_before: int = 24
        ) -> None:
            """
            Send activity reminder

            Typically sent 24 hours before activity
            """
            user = self.db.query(User).filter(User.id == user_id).first()
            activity = self.db.query(Activity).filter(Activity.id == activity_id).first()

            if not user or not activity:
                logger.warning(f"Cannot send reminder: user={user_id}, activity={activity_id}")
                return

            message = (
                f"Reminder: Activity Tomorrow!\n\n"
                f"{activity.title}\n"
                f"Date: {activity.date}\n"
                f"Time: {activity.start_time}\n"
                f"Location: {activity.location}\n\n"
                f"See you there!"
            )

            if user.phone:
                self.twilio.send_sms(user.phone, message)

        async def send_cancellation_notification(
            self,
            user_id: UUID,
            activity_id: UUID
        ) -> None:
            """Send notification when registration is cancelled"""
            user = self.db.query(User).filter(User.id == user_id).first()
            activity = self.db.query(Activity).filter(Activity.id == activity_id).first()

            if not user or not activity:
                logger.warning(f"Cannot send cancellation: user={user_id}, activity={activity_id}")
                return

            message = (
                f"Cancellation Confirmed\n\n"
                f"Activity: {activity.title}\n"
                f"Date: {activity.date}\n\n"
                f"You have been removed from this activity."
            )

            if user.phone:
                self.twilio.send_sms(user.phone, message)
    ```
  </action>
  <verify>
    - File compiles: `python -c "from app.services.notification_service import NotificationService"`
    - All TODO comments replaced with actual calls
    - Logging added for warning cases
  </verify>
  <done>NotificationService uses TwilioClient for all notification methods</done>
</task>

<task type="auto">
  <name>Task 3: Add environment variables to .env.example</name>
  <files>backend/.env.example</files>
  <action>
    Update or create `backend/.env.example` with Twilio configuration:

    ```
    # Notification Settings
    # Set to 'false' to use real Twilio (requires credentials below)
    USE_MOCK_NOTIFICATIONS=true

    # Twilio Credentials (only needed when USE_MOCK_NOTIFICATIONS=false)
    TWILIO_ACCOUNT_SID=your_account_sid_here
    TWILIO_AUTH_TOKEN=your_auth_token_here
    TWILIO_FROM_PHONE=+1234567890
    TWILIO_WHATSAPP_FROM=whatsapp:+1234567890
    ```

    If .env.example doesn't exist, create it with all required env vars.
    If it exists, append the Twilio section.
  </action>
  <verify>
    - backend/.env.example contains USE_MOCK_NOTIFICATIONS
    - Contains all 4 Twilio config vars
  </verify>
  <done>Environment template includes notification configuration</done>
</task>

<task type="auto">
  <name>Task 4: Wire notifications into matches API</name>
  <files>backend/app/api/matches.py</files>
  <action>
    Update the matches API to call notification service after creating/cancelling matches:

    In create_volunteer_match, after `db.refresh(db_match)`:
    ```python
    # Send notification (runs in background, doesn't block response)
    from app.services.notification_service import NotificationService
    notification_service = NotificationService(db)
    await notification_service.send_volunteer_match_confirmation(
        volunteer_id=current_user.id,
        activity_id=match.activity_id
    )
    ```

    In cancel_volunteer_match, after `db.commit()`:
    ```python
    # Send cancellation notification
    from app.services.notification_service import NotificationService
    notification_service = NotificationService(db)
    await notification_service.send_cancellation_notification(
        user_id=current_user.id,
        activity_id=match.activity_id
    )
    ```

    Note: The notification calls are async but we await them to ensure they complete.
    In production, you might want to use a background task queue instead.
  </action>
  <verify>
    - create_volunteer_match calls send_volunteer_match_confirmation
    - cancel_volunteer_match calls send_cancellation_notification
    - No import errors when starting backend
  </verify>
  <done>Matches API triggers notifications on match/cancel</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TwilioClient wrapper created with mock mode
- [ ] NotificationService uses TwilioClient
- [ ] .env.example updated with notification config
- [ ] Matches API calls notification service
- [ ] Backend starts without errors
- [ ] Creating a match logs mock notification to console
</verification>

<success_criteria>
- Mock notifications log to console clearly
- Real Twilio mode available when credentials provided
- Notification service is called from API endpoints
- No changes to existing frontend behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-person3-backend/04-02-SUMMARY.md`
</output>
