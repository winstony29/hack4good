---
phase: 02-experience-lead
plan: 03
type: execute
domain: accessibility-backend
---

<objective>
Implement the Translation backend endpoint using Google Cloud Translate API.

Purpose: Enable users to view content in their preferred language (English, Mandarin, Malay, Tamil).
Output: Working /accessibility/translate endpoint that returns translated text (mock or real Google Translate).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Existing backend infrastructure:**
@backend/app/integrations/google_translate.py
@backend/app/api/accessibility.py
@backend/app/core/config.py

**Key patterns:**
- GoogleTranslateClient stub exists with translate and detect_language methods
- API endpoint stub exists at /accessibility/translate (returns 501)
- Settings include GOOGLE_APPLICATION_CREDENTIALS and GOOGLE_PROJECT_ID (optional)
- When credentials missing, should return mock translated text
- Frontend AccessibilityContext.translate() already calls this endpoint

**Frontend consumer:**
@frontend/src/contexts/AccessibilityContext.jsx
@frontend/src/utils/constants.js (LANGUAGES, LANGUAGE_LABELS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Google Translate client with fallback mock</name>
  <files>backend/app/integrations/google_translate.py</files>
  <action>
Complete the Google Translate client implementation:

1. Add proper import for google-cloud-translate (already in requirements.txt)
2. Initialize client in __init__ when credentials are available
3. Implement translate method:
   - If credentials exist, call real Google Translate API
   - If not, return mock translation: prepend language code to text
4. Implement detect_language method with fallback to "en"
5. Handle API errors gracefully - return mock on failure

Supported language codes:
- en (English)
- zh (Chinese/Mandarin)
- ms (Malay)
- ta (Tamil)

Mock translation format: "[{target_lang}] {original_text}" for easy debugging
  </action>
  <verify>Python syntax check: `python -c "from app.integrations.google_translate import GoogleTranslateClient; print('OK')"`</verify>
  <done>GoogleTranslateClient can translate with real API or mock fallback</done>
</task>

<task type="auto">
  <name>Task 2: Wire Translation endpoint to use Google Translate client</name>
  <files>backend/app/api/accessibility.py</files>
  <action>
Update the /accessibility/translate endpoint:

1. Import and instantiate GoogleTranslateClient
2. In translate_text function:
   - Get text, source_language, target_language from request
   - Validate language codes are supported (en, zh, ms, ta)
   - Call google_translate_client.translate(text, source_language, target_language)
   - Return the translated text in response
3. Remove the HTTPException(501) - endpoint should work now
4. Return proper TranslationResponse

Handle edge cases:
- Empty text -> Return error 400
- Same source/target language -> Return original text
- Unsupported language -> Return error 400 with supported languages list
- Very long text -> Truncate to 10000 chars max
  </action>
  <verify>curl -X POST "http://localhost:8000/accessibility/translate" -H "Content-Type: application/json" -d '{"text":"Hello","source_language":"en","target_language":"zh"}' (needs backend running)</verify>
  <done>Translation endpoint returns translated text instead of 501 error</done>
</task>

<task type="auto">
  <name>Task 3: Create AccessibilityService to coordinate TTS and Translation</name>
  <files>backend/app/services/accessibility_service.py</files>
  <action>
Create/update the accessibility service to coordinate both integrations:

1. Create AccessibilityService class
2. Initialize both ElevenLabsClient and GoogleTranslateClient
3. Add methods:
   - text_to_speech(text: str, language: str) -> dict
   - translate(text: str, source_lang: str, target_lang: str) -> dict
   - get_supported_languages() -> list
4. Add convenience method: translate_and_speak(text, target_lang) for future use

This creates a clean service layer that the API endpoints can use, following the existing service pattern in the codebase.
  </action>
  <verify>Python syntax check: `python -c "from app.services.accessibility_service import AccessibilityService; print('OK')"`</verify>
  <done>AccessibilityService coordinates TTS and Translation clients</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Backend starts without errors
- [ ] Translate endpoint responds: `curl -X POST localhost:8000/accessibility/translate -H "Content-Type: application/json" -d '{"text":"Hello","source_language":"en","target_language":"zh"}'`
- [ ] Response includes translated_text field
- [ ] No 501 error returned
- [ ] Languages endpoint still works: `curl localhost:8000/accessibility/languages`
</verification>

<success_criteria>

- GoogleTranslateClient.translate() works with mock fallback
- /accessibility/translate endpoint returns translated text
- Frontend can call endpoint and receive translation response
- Works without Google credentials (mock mode)
- Works with Google credentials (real mode) if available
- AccessibilityService provides clean coordination layer
</success_criteria>

<output>
After completion, create `.planning/phases/02-experience-lead/02-03-SUMMARY.md`
</output>
