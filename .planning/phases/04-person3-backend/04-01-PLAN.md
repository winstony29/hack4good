---
phase: 04-person3-backend
plan: 01
type: execute
---

<objective>
Implement the Matches API endpoints for volunteer-activity matching.

Purpose: Complete the 4 stub endpoints in api/matches.py with full CRUD functionality
Output: Working matches API that creates, reads, and cancels volunteer matches
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@backend/app/api/matches.py - Current stub endpoints
@backend/app/db/models.py - VolunteerMatch model definition
@backend/app/models/registration.py - Pydantic schemas
@backend/app/core/enums.py - RegistrationStatus enum
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement get_available_activities endpoint</name>
  <files>backend/app/api/matches.py</files>
  <action>
    Implement the `/available` endpoint to return activities available for matching:

    ```python
    @router.get("/available", response_model=List[ActivityResponse])
    async def get_available_activities(
        current_user = Depends(get_current_volunteer),
        db: Session = Depends(get_db)
    ):
        from datetime import date
        from app.db.models import Activity, VolunteerMatch
        from app.core.enums import RegistrationStatus

        # Get IDs of activities volunteer is already matched to
        matched_activity_ids = db.query(VolunteerMatch.activity_id).filter(
            VolunteerMatch.volunteer_id == current_user.id,
            VolunteerMatch.status != RegistrationStatus.CANCELLED
        ).all()
        matched_ids = [m[0] for m in matched_activity_ids]

        # Query future activities not already matched
        activities = db.query(Activity).filter(
            Activity.date >= date.today(),
            ~Activity.id.in_(matched_ids) if matched_ids else True
        ).order_by(Activity.date, Activity.start_time).all()

        return activities
    ```

    Key logic:
    - Only returns future activities (date >= today)
    - Excludes activities volunteer is already matched to
    - Excludes cancelled matches (so volunteer can re-match if cancelled)
    - Orders by date and time for swiper presentation
  </action>
  <verify>
    - Endpoint compiles without errors
    - Returns empty list when no activities available
    - Excludes already-matched activities
  </verify>
  <done>get_available_activities returns filtered, ordered activities list</done>
</task>

<task type="auto">
  <name>Task 2: Implement create_volunteer_match endpoint</name>
  <files>backend/app/api/matches.py</files>
  <action>
    Implement the POST `/` endpoint to create a volunteer match (swipe right):

    ```python
    @router.post("", response_model=VolunteerMatchResponse, status_code=status.HTTP_201_CREATED)
    async def create_volunteer_match(
        match: VolunteerMatchCreate,
        current_user = Depends(get_current_volunteer),
        db: Session = Depends(get_db)
    ):
        from datetime import date
        from app.db.models import Activity, VolunteerMatch
        from app.core.enums import RegistrationStatus

        # Validate activity exists and is in the future
        activity = db.query(Activity).filter(Activity.id == match.activity_id).first()
        if not activity:
            raise HTTPException(status_code=404, detail="Activity not found")

        if activity.date < date.today():
            raise HTTPException(status_code=400, detail="Cannot match to past activity")

        # Check for existing active match
        existing = db.query(VolunteerMatch).filter(
            VolunteerMatch.volunteer_id == current_user.id,
            VolunteerMatch.activity_id == match.activity_id,
            VolunteerMatch.status != RegistrationStatus.CANCELLED
        ).first()

        if existing:
            raise HTTPException(status_code=409, detail="Already matched to this activity")

        # Check for time conflicts with other matched activities
        conflicting = db.query(VolunteerMatch).join(Activity).filter(
            VolunteerMatch.volunteer_id == current_user.id,
            VolunteerMatch.status != RegistrationStatus.CANCELLED,
            Activity.date == activity.date,
            Activity.start_time < activity.end_time,
            Activity.end_time > activity.start_time
        ).first()

        if conflicting:
            raise HTTPException(status_code=409, detail="Time conflict with another matched activity")

        # Create the match
        db_match = VolunteerMatch(
            volunteer_id=current_user.id,
            activity_id=match.activity_id,
            status=RegistrationStatus.CONFIRMED
        )
        db.add(db_match)
        db.commit()
        db.refresh(db_match)

        # TODO: Send notification (will be wired in 04-02)

        return db_match
    ```

    Validation logic:
    - Activity must exist
    - Activity must be in the future
    - No duplicate active matches
    - No time conflicts with other matches on same day
  </action>
  <verify>
    - Returns 404 for non-existent activity
    - Returns 400 for past activity
    - Returns 409 for duplicate match
    - Returns 409 for time conflict
    - Returns 201 with match data on success
  </verify>
  <done>create_volunteer_match creates match with full validation</done>
</task>

<task type="auto">
  <name>Task 3: Implement get_volunteer_matches endpoint</name>
  <files>backend/app/api/matches.py</files>
  <action>
    Implement the GET `/user/{user_id}` endpoint:

    ```python
    @router.get("/user/{user_id}", response_model=List[VolunteerMatchWithActivity])
    async def get_volunteer_matches(
        user_id: UUID,
        current_user = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        from app.db.models import VolunteerMatch
        from app.core.enums import Role

        # Authorization: can view own matches, or staff can view any
        if current_user.id != user_id and current_user.role != Role.STAFF:
            raise HTTPException(status_code=403, detail="Not authorized to view these matches")

        # Fetch matches with activity details (eager load)
        matches = db.query(VolunteerMatch).filter(
            VolunteerMatch.volunteer_id == user_id
        ).options(
            joinedload(VolunteerMatch.activity)
        ).order_by(VolunteerMatch.matched_at.desc()).all()

        return matches
    ```

    Add import at top of file:
    ```python
    from sqlalchemy.orm import joinedload
    ```

    Authorization:
    - Users can view their own matches
    - Staff can view any volunteer's matches
  </action>
  <verify>
    - Returns 403 when non-staff tries to view other user's matches
    - Returns matches with activity details included
    - Results ordered by matched_at descending
  </verify>
  <done>get_volunteer_matches returns matches with authorization check</done>
</task>

<task type="auto">
  <name>Task 4: Implement cancel_volunteer_match endpoint</name>
  <files>backend/app/api/matches.py</files>
  <action>
    Implement the DELETE `/{match_id}` endpoint:

    ```python
    @router.delete("/{match_id}", status_code=status.HTTP_204_NO_CONTENT)
    async def cancel_volunteer_match(
        match_id: UUID,
        current_user = Depends(get_current_volunteer),
        db: Session = Depends(get_db)
    ):
        from app.db.models import VolunteerMatch
        from app.core.enums import RegistrationStatus

        # Fetch the match
        match = db.query(VolunteerMatch).filter(VolunteerMatch.id == match_id).first()

        if not match:
            raise HTTPException(status_code=404, detail="Match not found")

        # Verify ownership
        if match.volunteer_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to cancel this match")

        # Check if already cancelled
        if match.status == RegistrationStatus.CANCELLED:
            raise HTTPException(status_code=400, detail="Match already cancelled")

        # Update status to cancelled
        match.status = RegistrationStatus.CANCELLED
        db.commit()

        # TODO: Send cancellation notification (will be wired in 04-02)

        return None
    ```

    Logic:
    - Match must exist
    - Only the volunteer who created the match can cancel it
    - Cannot cancel an already-cancelled match
    - Soft delete via status change (keeps history)
  </action>
  <verify>
    - Returns 404 for non-existent match
    - Returns 403 when trying to cancel another user's match
    - Returns 400 when match already cancelled
    - Returns 204 on successful cancellation
  </verify>
  <done>cancel_volunteer_match performs soft delete with authorization</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 4 endpoints implemented (no more 501 responses or empty returns)
- [ ] Backend starts without errors: `cd backend && python -m uvicorn app.main:app --reload`
- [ ] Test each endpoint manually with curl or API client
- [ ] Existing tests still pass (if any)
</verification>

<success_criteria>
- get_available_activities returns filtered future activities
- create_volunteer_match creates match with full validation
- get_volunteer_matches returns matches with authorization
- cancel_volunteer_match performs soft delete
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/04-person3-backend/04-01-SUMMARY.md`
</output>
